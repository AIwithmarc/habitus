/*! Chart.js Fallback v3.9.1 - Essential functionality for Habitus */
(function(global, factory) {
    'use strict';
    global.Chart = factory();
})(this, function() {
    'use strict';

    // Minimal Chart.js implementation with essential chart types
    class Chart {
        constructor(ctx, config) {
            this.ctx = typeof ctx === 'string' ? document.getElementById(ctx).getContext('2d') : ctx;
            this.config = config;
            this.data = config.data || {};
            this.options = config.options || {};
            this.type = config.type || 'bar';
            this.canvas = this.ctx.canvas;
            this.destroyed = false;
            
            this.init();
        }

        init() {
            this.setupCanvas();
            this.render();
            this.setupEvents();
        }

        setupCanvas() {
            const canvas = this.canvas;
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            this.ctx.scale(dpr, dpr);
            
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        setupEvents() {
            // Basic resize handling
            const resizeObserver = new ResizeObserver(() => {
                if (!this.destroyed) {
                    this.setupCanvas();
                    this.render();
                }
            });
            resizeObserver.observe(this.canvas);
            this._resizeObserver = resizeObserver;
        }

        render() {
            if (this.destroyed) return;
            
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            const rect = this.canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            switch (this.type) {
                case 'bar':
                    this.renderBar(width, height);
                    break;
                case 'doughnut':
                    this.renderDoughnut(width, height);
                    break;
                case 'line':
                    this.renderLine(width, height);
                    break;
                default:
                    this.renderFallback(width, height);
            }
        }

        renderBar(width, height) {
            const { labels, datasets } = this.data;
            if (!datasets || !datasets[0] || !datasets[0].data) return;

            const data = datasets[0].data;
            const colors = datasets[0].backgroundColor || ['#4f46e5', '#059669', '#eab308', '#9ca3af'];
            const padding = 40;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            const maxValue = Math.max(...data.filter(v => typeof v === 'number'));
            if (maxValue === 0) maxValue = 1;
            
            const barWidth = chartWidth / data.length * 0.6;
            const barSpacing = chartWidth / data.length;

            // Draw bars
            data.forEach((value, index) => {
                if (typeof value !== 'number') return;
                
                const barHeight = (value / maxValue) * chartHeight;
                const x = padding + index * barSpacing + (barSpacing - barWidth) / 2;
                const y = height - padding - barHeight;
                
                this.ctx.fillStyle = Array.isArray(colors) ? colors[index % colors.length] : colors;
                this.ctx.fillRect(x, y, barWidth, barHeight);
                
                // Draw value labels
                this.ctx.fillStyle = '#374151';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(value.toString(), x + barWidth / 2, y - 5);
                
                // Draw x-axis labels
                if (labels && labels[index]) {
                    this.ctx.fillText(labels[index], x + barWidth / 2, height - padding + 20);
                }
            });

            // Draw axes
            this.ctx.strokeStyle = '#e5e7eb';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(padding, height - padding);
            this.ctx.lineTo(width - padding, height - padding);
            this.ctx.moveTo(padding, padding);
            this.ctx.lineTo(padding, height - padding);
            this.ctx.stroke();
        }

        renderDoughnut(width, height) {
            const { labels, datasets } = this.data;
            if (!datasets || !datasets[0] || !datasets[0].data) return;

            const data = datasets[0].data;
            const colors = datasets[0].backgroundColor || ['#4ade80', '#f87171'];
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 20;
            const innerRadius = radius * 0.6;
            
            const total = data.reduce((sum, value) => sum + (typeof value === 'number' ? value : 0), 0);
            if (total === 0) return;
            
            let currentAngle = -Math.PI / 2;
            
            data.forEach((value, index) => {
                if (typeof value !== 'number' || value === 0) return;
                
                const sliceAngle = (value / total) * 2 * Math.PI;
                
                this.ctx.fillStyle = Array.isArray(colors) ? colors[index % colors.length] : colors;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                this.ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
                this.ctx.closePath();
                this.ctx.fill();
                
                currentAngle += sliceAngle;
            });

            // Draw legend
            if (labels) {
                const legendY = height - 60;
                let legendX = 20;
                
                labels.forEach((label, index) => {
                    if (typeof data[index] !== 'number') return;
                    
                    // Legend color box
                    this.ctx.fillStyle = Array.isArray(colors) ? colors[index % colors.length] : colors;
                    this.ctx.fillRect(legendX, legendY, 12, 12);
                    
                    // Legend text
                    this.ctx.fillStyle = '#374151';
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(label, legendX + 20, legendY + 10);
                    
                    legendX += this.ctx.measureText(label).width + 50;
                });
            }
        }

        renderLine(width, height) {
            const { labels, datasets } = this.data;
            if (!datasets || !datasets[0] || !datasets[0].data) return;

            const data = datasets[0].data;
            const color = datasets[0].borderColor || '#4f46e5';
            const fillColor = datasets[0].backgroundColor || 'rgba(79, 70, 229, 0.1)';
            const padding = 40;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            const maxValue = Math.max(...data.filter(v => typeof v === 'number'));
            const minValue = Math.min(...data.filter(v => typeof v === 'number'));
            const range = maxValue - minValue || 1;
            
            const points = [];
            data.forEach((value, index) => {
                if (typeof value !== 'number') return;
                
                const x = padding + (index / (data.length - 1)) * chartWidth;
                const y = height - padding - ((value - minValue) / range) * chartHeight;
                points.push({ x, y, value });
            });

            // Draw fill area if specified
            if (datasets[0].fill && points.length > 1) {
                this.ctx.fillStyle = fillColor;
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, height - padding);
                points.forEach(point => this.ctx.lineTo(point.x, point.y));
                this.ctx.lineTo(points[points.length - 1].x, height - padding);
                this.ctx.closePath();
                this.ctx.fill();
            }

            // Draw line
            if (points.length > 1) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);
                points.slice(1).forEach(point => this.ctx.lineTo(point.x, point.y));
                this.ctx.stroke();
            }

            // Draw points
            points.forEach(point => {
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                this.ctx.fill();
            });

            // Draw x-axis labels
            if (labels) {
                this.ctx.fillStyle = '#374151';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                
                labels.forEach((label, index) => {
                    const x = padding + (index / (labels.length - 1)) * chartWidth;
                    this.ctx.fillText(label, x, height - padding + 20);
                });
            }

            // Draw axes
            this.ctx.strokeStyle = '#e5e7eb';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(padding, height - padding);
            this.ctx.lineTo(width - padding, height - padding);
            this.ctx.moveTo(padding, padding);
            this.ctx.lineTo(padding, height - padding);
            this.ctx.stroke();
        }

        renderFallback(width, height) {
            this.ctx.fillStyle = '#f3f4f6';
            this.ctx.fillRect(0, 0, width, height);
            
            this.ctx.fillStyle = '#6b7280';
            this.ctx.font = '16px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('Chart Offline', width / 2, height / 2);
        }

        update(mode = 'default') {
            if (this.destroyed) return;
            this.render();
        }

        destroy() {
            this.destroyed = true;
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
        }

        static register(...components) {
            // Compatibility method - does nothing in fallback
        }
    }

    // Add static methods for compatibility
    Chart.defaults = {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
            legend: {
                display: true,
                position: 'top'
            },
            title: {
                display: false
            }
        },
        scales: {
            x: {
                display: true,
                grid: {
                    display: true
                }
            },
            y: {
                display: true,
                beginAtZero: true,
                grid: {
                    display: true
                }
            }
        }
    };

    Chart.register = function(...components) {
        // Compatibility method - does nothing in fallback
    };

    Chart.version = '3.9.1-fallback';

    return Chart;
});

// Console notification about fallback
console.log('[Chart.js] Running offline fallback version. Limited functionality available.');
